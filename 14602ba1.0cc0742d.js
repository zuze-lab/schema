(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{63:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return o})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return m}));var n=a(3),r=a(7),s=(a(0),a(91)),c=a(95),i={id:"schemas",title:"Schemas",sidebar_label:"Schemas"},o={unversionedId:"schemas",id:"schemas",isDocsHomePage:!1,title:"Schemas",description:"@zuze/schema makes the following schemas available for you to use:",source:"@site/docs/schemas.md",slug:"/schemas",permalink:"/schema/docs/schemas",editUrl:"https://github.com/zuze-lab/schema/edit/master/website/docs/schemas.md",version:"current",sidebar_label:"Schemas",sidebar:"someSidebar",previous:{title:"Extending",permalink:"/schema/docs/extending"},next:{title:"Transforms",permalink:"/schema/docs/transforms"}},l=[{value:"Schemas",id:"schemas",children:[{value:"mixed",id:"mixed",children:[]},{value:"string",id:"string",children:[]},{value:"number",id:"number",children:[]},{value:"boolean",id:"boolean",children:[]},{value:"date",id:"date",children:[]},{value:"lazy",id:"lazy",children:[]},{value:"object",id:"object",children:[]},{value:"array",id:"array",children:[]},{value:"tuple",id:"tuple",children:[]}]},{value:"Functions",id:"functions",children:[{value:"cast",id:"cast",children:[]},{value:"validate",id:"validate",children:[]},{value:"validateSync",id:"validatesync",children:[]},{value:"validateAt",id:"validateat",children:[]},{value:"validateAtSync",id:"validateatsync",children:[]},{value:"isValid",id:"isvalid",children:[]},{value:"isValidSync",id:"isvalidsync",children:[]},{value:"isValidAt",id:"isvalidat",children:[]},{value:"isValidSyncAt",id:"isvalidsyncat",children:[]},{value:"getErrors",id:"geterrors",children:[]},{value:"getErrorsSync",id:"geterrorssync",children:[]}]}],b={rightToc:l};function m(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(n.a)({},b,a,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"@zuze/schema")," makes the following schemas available for you to use:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#mixed"}),"mixed")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#string"}),"string")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#number"}),"number")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#boolean"}),"boolean")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#date"}),"date")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#lazy"}),"lazy")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#object"}),"object")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#array"}),"array")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"#tuple"}),"tuple"))),Object(s.b)("p",null,"Unlike yup, joi, and ajv, ",Object(s.b)("strong",{parentName:"p"},"@zuze/schema")," was designed to be functional and that means that it doesn't use methods. All validators can be added to all schemas regardless of if they make sense (but we'll warn you if you're doing something silly) via the ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/utilities#tests"}),Object(s.b)("inlineCode",{parentName:"a"},"tests"))," function."),Object(s.b)("p",null,"Because of this, our documentation of each schema focuses primarily on the default transforms that come with each schema because, again, schemas don't have methods."),Object(s.b)("h2",{id:"schemas"},"Schemas"),Object(s.b)("p",null,"All schema constructor functions (except ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#lazy"}),"lazy"),") have the same signature:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"schema(...defs: Partial<SchemaDefinition>[])\n")),Object(s.b)("p",null,Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#object"}),"object"),", ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#array"}),"array")," and ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#date"}),"date")," may also accept different parameters as their first parameter."),Object(s.b)("h3",{id:"mixed"},"mixed"),Object(s.b)("p",null,"A mixed schema is an abstract schema, it's use is generally not encouraged except maybe for the base of a conditional schema. "),Object(s.b)("p",null,Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/creating-schemas#partial-definitions"}),"Partial definitions")," can be passed to it as arguments just like any other:"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"NOTE: ",Object(s.b)("inlineCode",{parentName:"strong"},"mixed")," schemas DO NOT perform any default transform on its value at validation/cast time.")),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { ast } from '@zuze/schema'\nconst { createSchema } = ast;\n\nconst sku = createSchema({\n    schema: 'mixed',\n    nullable: true,\n    label:'sku',\n    // a contrived example, I know :)\n    conditons:[\n        {\n            when: { product: { tests: [['is','snowboard']]} },\n            then: { schema: 'string', tests: [['matches','^[0-9A-Z]{10,20}$']]] },\n            otherwise: { schema: 'number', tests: [['min',10]] }\n        }\n    ]\n});\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { string, label, nullable, conditions, when, tests, matches, min } from '@zuze/schema';\n\nconst sku = mixed(\n  label('sku'),\n  nullable(true),\n  conditions(\n    when('product', {\n      is: 'snowboard',\n      then: () => string(tests(matches('^[0-9A-Z]{10,20}$'))),\n      otherwise: () => number(tests(min(10)))\n    })\n  )\n);\n"))),Object(s.b)("h3",{id:"string"},"string"),Object(s.b)("p",null,"Accepts values that are strings and attempts to cast the subject value to a string at validation/cast time."),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { ast, cast, getErrors } from '@zuze/schema'\nconst { createSchema } = ast;\n\nconst schema = createSchema({\n    schema: 'string',\n    tests: ['required', ['min',10]]\n});\n\ncast(schema,9) // \"9\"\nisValidSync(schema,9); //false\ngetErrors(schema,9); // field must not be shorter than 10 characters\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { string, tests, required, min, getErrors, isValidSync } from '@zuze/schema';\n\nconst schema = string(tests(required(),min(10)))\n\ncast(schema,9) // \"9\"\nisValidSync(schema,9); //false\ngetErrors(schema,9); // field must not be shorter than 10 characters\n"))),Object(s.b)("h3",{id:"number"},"number"),Object(s.b)("p",null,"A number schema attempts to coerce the subject value to a numeric value, if it isn't one."),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { ast, cast, getErrors } from '@zuze/schema'\nconst { createSchema } = ast;\n\nconst schema = createSchema({\n    schema: 'number',\n    tests: ['required', ['between',10,20]]\n});\n\ncast(schema, \"18\") // \"18\"\nisValidSync(schema, \"18\"); // true\ngetErrors(schema, \"7\"); // field must be between 10 and 20\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'import { string, tests, required, between, getErrors, isValidSync } from \'@zuze/schema\';\n\nconst schema = string(tests(required(),between(10,20)))\n\ncast(schema, "18") // 18\nisValidSync(schema, "18"); // true\ngetErrors(schema, "7"); // field must be between 10 and 20\n'))),Object(s.b)("h3",{id:"boolean"},"boolean"),Object(s.b)("p",null,"A boolean schema attempts to coerce the subject value to a boolean (starting to notice a pattern?)"),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'import { ast, cast, validateSync, getErrors } from \'@zuze/schema\'\nconst { createSchema } = ast;\n\nconst schema = createSchema({\n    schema: \'boolean\',\n    typeError: \'must be a boolean\'\n});\n\ncast(schema, "ture") // TypeError\nvalidateSync(schema,"ture") // ValidationError - must be a boolean\nisValidSync(schema, "true"); // true\ngetErrors(schema, "ture"); // must be a boolean\n')),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'import { cast, boolean, typeError, getErrors, validateSync, isValidSync } from \'@zuze/schema\';\n\nconst schema = boolean(typeError(\'must be a boolean\'))\n\ncast(schema, "ture") // throws TypeError\nvalidateSync(schema,"ture") // throws ValidationError - must be a boolean\nisValidSync(schema, "true"); // true\ngetErrors(schema, "ture"); // must be a boolean\n'))),Object(s.b)("h3",{id:"date"},"date"),Object(s.b)("p",null,"A date schema is the first deviation from the regular pattern. Instead of only accepting partial schema definitions, it can accept a function (",Object(s.b)("strong",{parentName:"p"},"only as it's first parameter"),"). If a function is given, that function will be used as a mechanism to parse the subject value to convert it to a Date object. If no function is given it will use ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"https://date-fns.org/v2.10.0/docs/parseISO"}),"date-fns parseISO")," (optional dependency, don't forget to install it!)."),Object(s.b)("p",null,"Providing your own parser allows you to tree-shake date-fns if you don't need it, or it also allows you to do some really cool ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"https://sugarjs.com/dates/#/Parsing"}),"relative date parsing")," using other libraries."),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { Date as SugarDate } from 'sugar-date';\nimport { ast, cast } from '@zuze/schema';\nconst { createSchema } = ast;\n\nconst schema = createSchema({schema: 'date'},{dateParser:SugarDate.create});\ncast(schema, 'last wednesday'); //Wed Mar 11 2020 00:00:00 GMT-0300 (Atlantic Daylight Time)\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { Date as SugarDate } from 'sugar-date';\nimport { cast, date } from '@zuze/schema';\n\ncast(date(SugarDate.create), 'last wednesday'); //Wed Mar 11 2020 00:00:00 GMT-0300 (Atlantic Daylight Time)\n"))),Object(s.b)("h3",{id:"lazy"},"lazy"),Object(s.b)("p",null,"A lazy schema has no AST-equivalent because it doesn't need one. It's for developers who like to write functional code. "),Object(s.b)("p",null,"It accepts only a single parameter - a function that is called with the subject value that must return a schema."),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import { lazy, getErrors, isValidSync } from '@zuze/schema';\n\nconst schema = lazy(value => value === 9 ? number(tests(min(9))) : string(tests(min(9))));\n\ngetErrors(schema,\"9\"); // field must be no shorter than 9 characters\nisValidSync(schema,9); // true\n")),Object(s.b)("h3",{id:"object"},"object"),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"object")," and ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#array"}),Object(s.b)("inlineCode",{parentName:"a"},"array"))," are special schemas in that they have ",Object(s.b)("strong",{parentName:"p"},"inner"),"'s. They can have their own transforms/validations and they can also transform/validate their subschemas. In the case of an object this is done via it's ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/utilities#shape"}),Object(s.b)("inlineCode",{parentName:"a"},"shape"))),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'object',\n    shape: {\n        firstName:{\n            schema:'string',\n            tests:['required', ['min',5] ]\n        },\n        lastName:{\n            schema:'string',\n            tests:['required', ['min',5] ]\n        },        \n        address: {\n            schema: 'object',\n            shape: {\n                address1:{\n                    schema:'string',\n                    tests:['required', ['max',60] ]\n                },\n                province: {\n                    schema:'string',\n                    tests:['required',['oneOf',['BC','NL']]]\n                }\n                postalCode:{\n                    schema:'string',\n                    tests:['required', ['matches',/^[A-Z]\\d[A-Z]\\d[A-Z]\\d$/i]],\n                    conditions:[\n                        {\n                            // when province is BC\n                            when: { province: { tests: [['is','BC']] } },\n                            // postal code must start with a V\n                            then: { tests: ['matches',/^V/i]] }\n                        },\n                        {\n                            // when province is NL\n                            when: { province: { tests: [['is','NL']] } },\n                            // postal code must start with a A\n                            then: { tests: ['matches',/^V/i]] }\n                        },                        \n                    ],\n                    transforms:['strip'],\n                }            \n            }\n        },\n    }\n}\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"object({\n    firstName: string(tests(required(), min(5))),\n    lastName: string(tests(required(), min(5))),\n    address: object({\n        address1: string(tests(required(), max(60))),\n        province: string(tests(required(), oneOf(['BC','NL']))),\n        postalCode: string(\n            transforms(strip()),\n            tests(required(), matches(/^[A-Z]\\d[A-Z]\\d[A-Z]\\d$/i)),\n            conditions(\n                when('province', {\n                    is: 'BC',\n                    then: schema => extend(schema, tests(matches(/^V/i)))\n                }),\n                when('province', {\n                    is: 'NL',\n                    then: schema => extend(schema, tests(matches(/^A/i)))\n                })                \n            )\n        )\n    })\n})\n"))),Object(s.b)("h3",{id:"array"},"array"),Object(s.b)("p",null,"An array schema's subschema is given to it via ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/utilities#of"}),"of")),Object(s.b)("p",null,"Let's validate the following structure"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"{\n   users: [\n       {\n           firstName: 'freddie',\n           lastName: 'mercury'\n       }\n   ]\n}\n")),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'object',\n    shape: {\n        users: {\n             schema: 'array',\n             of: {\n                 schema: 'object',\n                 shape: {\n                     firstName: { \n                         schema: 'string', \n                         tests: ['required'] \n                     },\n                     lastName: { \n                        schema: 'string', \n                        tests: ['required'] \n                     },\n                 }\n             },\n             tests: [ ['min',4] ] // at least 4 user objects \n        }\n    }\n}\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"object({\n    users: array(\n        of(\n            object({\n                firstName: string(tests(required())),\n                lastName: string(tests(required())),\n            })\n        ),\n        tests( min(4) )\n    )\n})\n"))),Object(s.b)("h3",{id:"tuple"},"tuple"),Object(s.b)("p",null,"A ",Object(s.b)("inlineCode",{parentName:"p"},"tuple")," is an fixed length array of values. Instead of having a ",Object(s.b)("inlineCode",{parentName:"p"},"tuple")," schema, we just use ",Object(s.b)("inlineCode",{parentName:"p"},"array")," but instead of passing ",Object(s.b)("inlineCode",{parentName:"p"},"of")," a single schema, we pass it an array of schemas:"),Object(s.b)("p",null,"Let's look at a similar structure to above:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"{\n    users: [ ['Freddie', 'Mercury'] ]\n}\n")),Object(s.b)(c.a,{mdxType:"AstFn"},Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n  schema: 'object',\n  shape: {\n    users: {\n      schema: 'array',\n      of: {\n        schema: 'array',\n        of: [\n          {\n            schema: 'string',\n            label: 'first name',\n            tests: ['required'],\n          },\n          {\n            schema: 'string',\n            label: 'last name',\n            tests: ['required'],\n          },\n        ],\n      },\n      tests: [['min', 4]],\n    },\n  },\n};\n\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"object({\n  users: array(\n    array([\n      string(label('first name'), tests(required())),\n      string(label('last name'), tests(required())),\n    ]),\n    tests(min(4))\n  ),\n});\n"))),Object(s.b)("h2",{id:"functions"},"Functions"),Object(s.b)("p",null,"All schema operating functions accept the following arguments:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"schema: ",Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"/schema/docs/type-reference#schemadefinition"}),"SchemaDefinition")),Object(s.b)("li",{parentName:"ul"},"value: any;"),Object(s.b)("li",{parentName:"ul"},"options?: ",Object(s.b)("a",Object(n.a)({parentName:"li"},{href:"/schema/docs/type-reference#validationoptions"}),"ValidationOptions"))),Object(s.b)("h3",{id:"cast"},"cast"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"cast(schema: SchemaDefinition, value: any, options?: ValidationOptions): any"))),Object(s.b)("p",null,"Casts a value using a schema's transforms. Transforms are not run when the ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/type-reference#validationptions"}),"ValidationOption")," ",Object(s.b)("inlineCode",{parentName:"p"},"strict")," is ",Object(s.b)("inlineCode",{parentName:"p"},"true"),"."),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"cast(string(), 9); // 9\ncast(array(compact()),[1,0]); // [1]\n")),Object(s.b)("h3",{id:"validate"},"validate"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"validate(schema: SchemaDefinition, value: any, options: ValidationOptions): any"))),Object(s.b)("p",null,"When sync is false, returns a Promise that resolves to the passed in value or rejects with a ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/type-reference#validationerror"}),"ValidationError"),"."),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"await validate(string(tests(required())), ''); // ValidationError: field is required\n")),Object(s.b)("h3",{id:"validatesync"},"validateSync"),Object(s.b)("p",null,"Alias for ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#validate"}),"validate")," with ",Object(s.b)("inlineCode",{parentName:"p"},"{ sync: true }")," option. Returns the passed in value or throws a ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/type-reference#validationerror"}),"ValidationError")),Object(s.b)("h3",{id:"validateat"},"validateAt"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"validateAt(path: string, schema: SchemaDefinition, value: object | any[], options: ValidationOptions): any"))),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Note:")," The ",Object(s.b)("inlineCode",{parentName:"p"},"value")," passed in must be the value described by the entire schema definition, ",Object(s.b)("strong",{parentName:"p"},"not the value at ",Object(s.b)("inlineCode",{parentName:"strong"},"path")),"."),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = object({\n    fieldA:array(object({\n        fieldB:string(tests(min(10)))\n    }))\n})\n\nawait validateAt('fieldA[1].fieldB', schema, {\n    fieldA:[\n        { fieldB: 9 },\n        { fieldB: 'short' }\n    ]\n});\n\n// throws ValidationError field must be no shorter than 10 characters\n")),Object(s.b)("h3",{id:"validateatsync"},"validateAtSync"),Object(s.b)("p",null,"Alias for ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#validateat"}),"validateAt")," with ",Object(s.b)("inlineCode",{parentName:"p"},"{ sync: true }")," option."),Object(s.b)("h3",{id:"isvalid"},"isValid"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"isValid(schema: SchemaDefinition, value: any, options: ValidationOptions): Promise<boolean>"))),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"isValid")," and ",Object(s.b)("inlineCode",{parentName:"p"},"isValidSync")," ",Object(s.b)("strong",{parentName:"p"},"do not throw errors"),". These methods always return booleans or Promises that resolve to a boolean."),Object(s.b)("h3",{id:"isvalidsync"},"isValidSync"),Object(s.b)("p",null,"Alias for ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#isValid"}),"isValid")," with ",Object(s.b)("inlineCode",{parentName:"p"},"{ sync: true }")," option."),Object(s.b)("h3",{id:"isvalidat"},"isValidAt"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"isValid(path: string, schema: SchemaDefinition, value: any, options: ValidationOptions): boolean | Promise<boolean>"))),Object(s.b)("p",null,"Same as validateAt except this method always returns a boolean or a Promise that resolves to a boolean."),Object(s.b)("h3",{id:"isvalidsyncat"},"isValidSyncAt"),Object(s.b)("p",null,"Alias for ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#isValidAt"}),"isValidAt")," with ",Object(s.b)("inlineCode",{parentName:"p"},"{ sync: true }")," option."),Object(s.b)("h3",{id:"geterrors"},"getErrors"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},Object(s.b)("inlineCode",{parentName:"strong"},"getErrors(schema: SchemaDefinition, value: any, options?: ValidationOptions)"))),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"getErrors")," is similar to ",Object(s.b)("inlineCode",{parentName:"p"},"validate")," except that it returns (instead of throws) error messages."),Object(s.b)("p",null,"If accepts an option of ",Object(s.b)("inlineCode",{parentName:"p"},"multi: true")," to return error messages as an array if ",Object(s.b)("inlineCode",{parentName:"p"},"abortEarly")," is false."),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(tests(required(),between(5,10),email()));\n\ngetErrors(schema, 'jim'); // field must be between 5 and 10 characters\n\ngetErrors(schema, 'jim', { abortEarly: false, multi: true});\n/*\n[\n 'field must be between 5 and 10 characters'\n 'field must be a valid email address'\n]\n*/\n")),Object(s.b)("p",null,"In the case of on object schema it maps errors to an object where the paths are the keys:"),Object(s.b)("pre",null,Object(s.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"getErrors(\n    object({\n        firstName: string(tests(min(5))),\n        lastName: string(tests(between(5,10))),\n        address: object({\n            street: string(tests(required())),\n            city: string(tests(not('london'))), \n            postal: string(tests(max(6))),\n        })\n    }),\n    {\n        firstName: 'joe',\n        lastName: 'fred',\n        address: {\n            city: 'london',\n            postal: 'not a postal'\n        }\n    },\n    { \n        abortEarly: false, \n        sync: true \n    }\n);\n\n/*\n{\n    firstName: 'firstName must be not shorter than 5 characters',\n    lastName: 'lastName must be between 5 and 10 characters',\n    address.street: 'address.street is required',\n    address.city: 'address.city must not be london',\n    address.postal: 'address.postal must be no longer than 6 characters'\n}\n*/\n")),Object(s.b)("h3",{id:"geterrorssync"},"getErrorsSync"),Object(s.b)("p",null,"Alias for ",Object(s.b)("a",Object(n.a)({parentName:"p"},{href:"#getErrors"}),"getErrors")," with ",Object(s.b)("inlineCode",{parentName:"p"},"{ sync: true }")," option."))}m.isMDXComponent=!0},90:function(e,t,a){"use strict";function n(e){var t,a,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(a=n(e[t]))&&(r&&(r+=" "),r+=a);else for(t in e)e[t]&&(r&&(r+=" "),r+=t);return r}t.a=function(){for(var e,t,a=0,r="";a<arguments.length;)(e=arguments[a++])&&(t=n(e))&&(r&&(r+=" "),r+=t);return r}},91:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return p}));var n=a(0),r=a.n(n);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),b=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=b(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),m=b(a),d=n,p=m["".concat(c,".").concat(d)]||m[d]||u[d]||s;return a?r.a.createElement(p,i(i({ref:t},l),{},{components:a})):r.a.createElement(p,i({ref:t},l))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,c=new Array(s);c[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var l=2;l<s;l++)c[l]=a[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"},93:function(e,t,a){"use strict";var n=a(0),r=a(94);t.a=function(){var e=Object(n.useContext)(r.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},94:function(e,t,a){"use strict";var n=a(0),r=Object(n.createContext)(void 0);t.a=r},95:function(e,t,a){"use strict";a.d(t,"b",(function(){return p})),a.d(t,"a",(function(){return h}));var n=a(0),r=a.n(n),s=a(93),c=a(90),i=a(53),o=a.n(i),l=37,b=39;var m=function(e){var t=e.lazy,a=e.block,i=e.children,m=e.defaultValue,u=e.values,d=e.groupId,p=e.className,h=Object(s.a)(),j=h.tabGroupChoices,O=h.setTabGroupChoices,f=Object(n.useState)(m),g=f[0],y=f[1];if(null!=d){var v=j[d];null!=v&&v!==g&&u.some((function(e){return e.value===v}))&&y(v)}var N=function(e){y(e),null!=d&&O(d,e)},w=[];return r.a.createElement("div",null,r.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(c.a)("tabs",{"tabs--block":a},p)},u.map((function(e){var t=e.value,a=e.label;return r.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":g===t,className:Object(c.a)("tabs__item",o.a.tabItem,{"tabs__item--active":g===t}),key:t,ref:function(e){return w.push(e)},onKeyDown:function(e){!function(e,t,a){switch(a.keyCode){case b:!function(e,t){var a=e.indexOf(t)+1;e[a]?e[a].focus():e[0].focus()}(e,t);break;case l:!function(e,t){var a=e.indexOf(t)-1;e[a]?e[a].focus():e[e.length-1].focus()}(e,t)}}(w,e.target,e)},onFocus:function(){return N(t)},onClick:function(){N(t)}},a)}))),t?Object(n.cloneElement)(i.filter((function(e){return e.props.value===g}))[0],{className:"margin-vert--md"}):r.a.createElement("div",{className:"margin-vert--md"},i.map((function(e,t){return Object(n.cloneElement)(e,{key:t,hidden:e.props.value!==g})}))))},u=a(3);var d=function(e){var t=e.children,a=e.hidden,n=e.className;return r.a.createElement("div",Object(u.a)({role:"tabpanel"},{hidden:a,className:n}),t)},p=(a(91),function(e){var t=e.groupId,a=e.children,n=e.tabs,s=e.default;return r.a.createElement(m,{groupId:t,defaultValue:s||n[0],values:n.map((function(e){return{label:e,value:e}}))},n.map((function(e,t){return r.a.createElement(d,{key:e,value:e},a[t])})))}),h=function(e){var t=e.children,a=e.link;return r.a.createElement(r.a.Fragment,null,r.a.createElement(p,{groupId:"ast-fn",tabs:["ast","functional"]},t),a&&r.a.createElement(r.a.Fragment,null,r.a.createElement("a",{target:"_blank",href:a},"Try it on CodeSandbox!"),r.a.createElement("hr",null),r.a.createElement("br",null)))}}}]);