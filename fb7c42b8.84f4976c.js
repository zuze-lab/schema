(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{86:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return i})),t.d(a,"metadata",(function(){return l})),t.d(a,"rightToc",(function(){return o})),t.d(a,"default",(function(){return m}));var n=t(3),s=t(7),r=(t(0),t(91)),c=t(95),i={id:"validators",title:"Validators",sidebar_label:"Validators"},l={unversionedId:"validators",id:"validators",isDocsHomePage:!1,title:"Validators",description:"Options",source:"@site/docs/validators.md",slug:"/validators",permalink:"/schema/docs/validators",editUrl:"https://github.com/zuze-lab/schema/edit/master/website/docs/validators.md",version:"current",sidebar_label:"Validators",sidebar:"someSidebar",previous:{title:"Transforms",permalink:"/schema/docs/transforms"},next:{title:"Utilities",permalink:"/schema/docs/utilities"}},o=[{value:"Options",id:"options",children:[{value:"name",id:"name",children:[]},{value:"params",id:"params",children:[]},{value:"message",id:"message",children:[]}]},{value:"Validators",id:"validators",children:[{value:"required",id:"required",children:[]},{value:"is",id:"is",children:[]},{value:"not",id:"not",children:[]},{value:"oneOf",id:"oneof",children:[]},{value:"notOneOf",id:"notoneof",children:[]},{value:"same",id:"same",children:[]},{value:"different",id:"different",children:[]},{value:"matches",id:"matches",children:[]},{value:"email",id:"email",children:[]},{value:"min",id:"min",children:[]},{value:"max",id:"max",children:[]},{value:"includes",id:"includes",children:[]},{value:"oneOfType",id:"oneoftype",children:[]}]},{value:"Combination",id:"combination",children:[{value:"negate",id:"negate",children:[]},{value:"combine",id:"combine",children:[]},{value:"serial",id:"serial",children:[]}]}],b={rightToc:o};function m(e){var a=e.components,t=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},b,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"options"},"Options"),Object(r.b)("p",null,"All validators accept as their final argument the same set of options (optional):"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'{\n    name?: string; // the "type" of error in a ValidationError\n    params? object; // any parameters that can be interpolated into the message\n    message?: string | (params) => string; // the error message in the ValidationError\n}\n')),Object(r.b)("h3",{id:"name"},"name"),Object(r.b)("p",null,"By default, ",Object(r.b)("inlineCode",{parentName:"p"},"name")," is the ",Object(r.b)("inlineCode",{parentName:"p"},"name")," of the validator you are calling - i.e. the name for the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#oneOf"}),"oneOf")," validator is ",Object(r.b)("inlineCode",{parentName:"p"},"oneOf"),"."),Object(r.b)("h3",{id:"params"},"params"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"params")," differ from validator to validator and are provided to the string/message function for convenience. ",Object(r.b)("inlineCode",{parentName:"p"},"label")," is the only common parameter always available for interpolation. For more information about error messages see ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/validating#messages"}),"error messages"),"."),Object(r.b)("h3",{id:"message"},"message"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"message")," is a string or a function used to define the error message for this specific validator. If a string the appropriate parameters will be interpolated using ",Object(r.b)("inlineCode",{parentName:"p"},"${interpolationparam}"),"."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'string',\n    label:'first name',\n    tests: [['includes','fred',{ message:'The value of ${label} should include ${value}' }]\n}\n\ngetErrorsSync(createSchema(schema),'jim'); // The value of first name should include fred\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(label('first name'),tests(includes('fred',{ message:'The value of ${label} should include ${value}' })));\n\ngetErrorsSync(schema,'jim'); // The value of first name should include fred\n"))),Object(r.b)("h2",{id:"validators"},"Validators"),Object(r.b)("p",null,"Validators aren't always applicable to all schemas (",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#min"}),"min")," is not relevant for a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/schemas#boolean"}),"boolean schema"),", for instance) This is accomplished via a pre-validation hook which verifies that the current ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#validatordefinition"}),"ValidatorDefinition")," is applicable to the current schema."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note:")," ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," is considered a valid value for all validators except ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#required"}),"required"),"."),Object(r.b)("h3",{id:"required"},"required"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"required(options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,"Most of the time ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," is not validated. This is accomplished via the pre-validation ",Object(r.b)("inlineCode",{parentName:"p"},"check")," function that determines if a validator is applicable given a schema type/value."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"required")," does validate the value of ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," and it returns false if the value being validated is ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," or ",Object(r.b)("inlineCode",{parentName:"p"},"null"),"."),Object(r.b)("p",null,"In the case of an array, it also requires at least 1 element and in the case of a string it requires the string be non-empty (not ",Object(r.b)("inlineCode",{parentName:"p"},'""'),")."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"\nmatches({schema:'string', tests: ['required']}, null); // false\nmatches({schema:'string', tests: ['required']}, undefined); // false\nmatches({schema:'string', tests: ['required']}, ''); // false\nmatches({schema:'string', tests: ['required']}, 'a string!'); // true\n\nmatches({schema:'array', tests: ['required']}, []); // false\nmatches({schema:'array', tests: ['required']}, ['not empty']); // true\n\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"\nisValidSync(string(tests(required()))); // false\nisValidSync(string(tests(required()))); // false\nisValidSync(string(tests(required()))); // false\nisValidSync(string(tests(required()))); // false\n\n"))),Object(r.b)("h3",{id:"is"},"is"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"is(value: any | Ref, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,"Value being validated must equal (",Object(r.b)("inlineCode",{parentName:"p"},"==="),") the value/ref."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note:")," This validator is equivalent to ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#oneOf"}),"oneOf([value: any | Ref])"),", except the ValidationError ",Object(r.b)("inlineCode",{parentName:"p"},"type")," is ",Object(r.b)("inlineCode",{parentName:"p"},"is"),"."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'object',\n    shape: {\n        fieldB: {\n            tests: [['is', { ref: 'fieldA' }]]\n        }\n    }\n};\n\nmatches(schema, { fieldA: 'jim', fieldB: 'jim'}); // true\nmatches(schema, { fieldA: 'fred', fieldB: 'jim'}); // false\nmatches(schema, { fieldB: 'jim'}); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = object({\n    fieldB: schema(tests(is(ref('fieldA'))))\n});\n\nisValidSync(schema, { fieldA: 'jim', fieldB: 'jim'}); // true\nisValidSync(schema, { fieldA: 'fred', fieldB: 'jim'}); // false\nisValidSync(schema, { fieldB: 'jim'}); // false\n"))),Object(r.b)("h3",{id:"not"},"not"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"not(value: any | Ref, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#negate"}),"negate"),"-d form of ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#is"}),"is")),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'object',\n    shape: {\n        fieldB: {\n            tests: [['not', { ref:'fieldA' }]]\n        }\n    }\n};\n\nmatches(schema, { fieldA: 'jim', fieldB: 'jim' }); // false\nmatches(schema, { fieldA: 'fred', fieldB: 'jim' }); // true\nmatches(schema, { fieldB: 'jim' }); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = object({\n    fieldB: schema(tests(not(ref('fieldA'))))\n});\n\nisValidSync(schema, { fieldA: 'jim', fieldB: 'jim' }); // false\nisValidSync(schema, { fieldA: 'fred', fieldB: 'jim' }); // true\nisValidSync(schema, { fieldB: 'jim' }); // true\n"))),Object(r.b)("h3",{id:"oneof"},"oneOf"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"oneOf(value: Ref | Array<any | Ref>, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,"Value being validated must be one of the values given to ",Object(r.b)("inlineCode",{parentName:"p"},"oneOf")," OR if ",Object(r.b)("inlineCode",{parentName:"p"},"value")," is a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/schema/docs/type-reference#astRef"}),"ref")," then the value being validated must be one of the values in the reference."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note:")," Just a reminder that ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," is considered a valid value. If you need to test for ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," use ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#required"}),"required"),"."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'object',\n    shape: {\n        fieldB: {\n            tests: [['oneOf', ['a', 9, { ref: 'fieldA' }]]]\n        },\n        fieldC: {\n            tests: [['oneOf', { ref: 'fieldD' }]]\n        }\n    }\n};\n\nmatches(schema, { fieldA: 'jim', fieldB: 'jim'}); // true\nmatches(schema, { fieldA: 'fred', fieldB: 'a'}); // true\nmatches(schema, { fieldB: 'jim'}); // false\nmatches(schema, { fieldC: 'jim', fieldD: ['joe','fred' ]}); // false\nmatches(schema, { fieldC: 'joe', fieldD: ['joe','fred' ]}); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = object({\n    fieldB:schema(tests(oneOf(['a', 9, { ref: 'fieldA' })))\n});\n\nisValidSync(schema, { fieldA: 'jim', fieldB: 'jim'}); // true\nisValidSync(schema, { fieldA: 'fred', fieldB: 'a'}); // true\nisValidSync(schema, { fieldB: 'jim'}); // false\n"))),Object(r.b)("h3",{id:"notoneof"},"notOneOf"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"notOneOf(value: Array<any | Ref>, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#negate"}),"negate"),"-d form of ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#oneOf"}),"oneOf")),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'object',\n    shape: {\n        fieldB: {\n            tests: [['notOneOf', ['a', 9, ref:{ 'fieldA' }]]]\n        }\n    }\n};\n\nmatches(schema, { fieldA: 'jim', fieldB: 'jim'}); // false\nmatches(schema, { fieldA: 'fred', fieldB: 'a'}); // false\nmatches(schema, { fieldB: 'jim'}); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = object({\n    fieldB:schema(tests(notOneOf(['a', 9, { ref: 'fieldA' })))\n});\n\nisValidSync(schema, { fieldA: 'jim', fieldB: 'jim'}); // false\nisValidSync(schema, { fieldA: 'fred', fieldB: 'a'}); // false\nisValidSync(schema, { fieldB: 'jim'}); // true\n"))),Object(r.b)("h3",{id:"same"},"same"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"same(value: string, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,"Validation-sugar for ",Object(r.b)("inlineCode",{parentName:"p"},"is(ref(value))"),"."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'string',\n    tests: [['same', '$ctxValue']]\n}\n\nconst context = { ctxValue: 'someVal' };\n\nmatches(schema, 'someVal', { context }); // true\nmatches(schema, 'not some val', { context }); // false\nmatches(schema, 'someVal'); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(tests(same('$ctxValue')))\n\nisValidSync(schema, 'someVal', { context }); // true\nisValidSync(schema, 'not some val', { context }); // false\nisValidSync(schema, 'someVal'); // false\n"))),Object(r.b)("h3",{id:"different"},"different"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"different(value: string, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"ALL")),Object(r.b)("p",null,Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#negate"}),"negate"),"-d form of ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#same"}),"same")),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'string',\n    tests: [['different', '$ctxValue']]\n}\n\nconst context = { ctxValue: 'someVal' };\n\nmatches(schema, 'someVal', { context }); // false\nmatches(schema, 'not some val', { context }); // true\nmatches(schema, 'someVal'); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(tests(different('$ctxValue')))\n\nisValidSync(schema, 'someVal', { context }); // false\nisValidSync(schema, 'not some val', { context }); // true\nisValidSync(schema, 'someVal'); // true\n"))),Object(r.b)("h3",{id:"matches"},"matches"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"matches(value: string | RegExp | Array<string | RegExp>, options = { validateEmpty: boolean, ...ValidatorOptions })"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"STRING")),Object(r.b)("p",null,"Validates that the value being validated matches the provided string/regexp.\nIn the case of an array, the value being validated must match one of the provided string/regexp."),Object(r.b)("p",null,"Empty strings always return true unless ",Object(r.b)("inlineCode",{parentName:"p"},"validateEmpty: true")," is passed as an option."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"matches({schema:'string', tests: [['matches', 'rick']]}, ''); // true\nmatches({schema:'string', tests: [['matches', 'rick', { validateEmpty: true }]}, ''); // false\nmatches({schema:'string', tests: [['matches', 'rick']]}, 'frederick'); // true\nmatches({schema:'string', tests: [['matches', ['rick', 'joe']]] }, 'fredeoe'); // false\nmatches({schema:'string', tests: [['matches', ['rick', 'joe']]] }, 'fred and joe'); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"isValidSync(string(tests(matches('rick'))), ''); // true\nisValidSync(string(tests(matches('rick', { validateEmpty: true}))), ''); // false\nisValidSync(string(tests(matches('rick'))), 'frederick'); // true\nisValidSync(string(tests(matches(['rick', 'joe']))), 'frederoe'); // false\nisValidSync(string(tests(matches(['rick', 'joe']))), 'fred and joe'); // true\n"))),Object(r.b)("h3",{id:"email"},"email"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"email(options = { validateEmpty: boolean, ...ValidatorOptions })"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"STRINGS")),Object(r.b)("p",null,"Validates that the value is a valid e-mail address"),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"matches({schema:'string', tests: ['email']}, ''); // true\nmatches({schema:'string', tests: ['email', { validateEmpty:true }]}, ''); // false\nmatches({schema:'string', tests: ['email']}, 'me@you.com'); // true\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"isValidSync(string(tests(email())), ''); // true\nisValidSync(string(tests(email({ validateEmpty: true }))),''); // false\nisValidSync(string(tests(email())), 'me@you.com'); // true\n"))),Object(r.b)("h3",{id:"min"},"min"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"min(value: number | Ref, options = { inclusive: boolean, ...ValidatorOptions})"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"DATE, STRING, NUMBER, ARRAY")),Object(r.b)("p",null,"Validates a date, string, number, or array is no less than the given number or ref.\n",Object(r.b)("inlineCode",{parentName:"p"},"inclusive")," is true by default, if passed as false, then the value must be more than min"),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"matches({schema: 'string', tests: [['min', 10]]}, 'short'); // false\nmatches({schema: 'string', tests: [['min', 5]]}, 'short'); // true\nmatches({schema: 'string', tests: [['min', 5, { inclusive: false }]]}, 'short'); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"isValidSync(string(tests(min(10))), 'short'); // false\nisValidSync(string(tests(min(5))), 'short'); // true\nisValidSync(string(tests(min(5, { inclusive: false }))), 'short'); // false\n"))),Object(r.b)("h3",{id:"max"},"max"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"max(value: number | Ref, options = { inclusive: boolean = true, ...ValidatorOptions})"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"DATE, STRING, NUMBER, ARRAY")),Object(r.b)("p",null,"Validates a date, string, number, or array is no more than the given number or ref.\n",Object(r.b)("inlineCode",{parentName:"p"},"inclusive")," is true by default, if passed as false, then the value must be less than max."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"matches({schema: 'string', tests: [['max', 5]]}, 'not short'); // false\nmatches({schema: 'string', tests: [['max', 5]]}, 'short'); // true\nmatches({schema: 'string', tests: [['max', 5, { inclusive: false }]]}, 'short'); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"isValidSync(string(tests(max(5))), 'not short'); // false\nisValidSync(string(tests(max(5))), 'short'); // true\nisValidSync(string(tests(max(5, { inclusive: false }))), 'short'); // false\n"))),Object(r.b)("h3",{id:"includes"},"includes"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"includes(value: any | Ref, options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"STRING, ARRAY")),Object(r.b)("p",null,"Validates a string or array value includes the value (or ref):"),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'string',\n    tests: [['includes', 'rick']]\n};\n\nmatches(schema, 'frederick'); // true\nmatches(schema, 'frederoe'); // false\n\nconst arr = {\n    schema: 'array',\n    tests: [['includes', 'rick']]\n};\n\nmatches(arr, ['joe', 'jim', 'frederick']); // false\nmatches(arr, ['joe', 'jim', 'rick']); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"isValidSync(string(includes('rick')), 'frederick'); // true\nisValidSync(string(includes('rick')), 'frederoe'); // false\n\nisValidSync(array(includes('rick')), ['joe', 'jim', 'frederick']); // false\nisValidSync(array(includes('rick')), ['joe', 'jim', 'rick']); // true\n"))),Object(r.b)("h3",{id:"oneoftype"},"oneOfType"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"oneOfType(schemas: Schema[], options: ValidatorOptions)"))),Object(r.b)("p",null,"Applicable to schemas: ",Object(r.b)("strong",{parentName:"p"},"MIXED")),Object(r.b)("p",null,"This is a special validator (similar to joi's ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/hapijs/joi/blob/master/API.md#alternatives"}),"alternatives"),") that validates a value to be one of a schema type."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema: 'mixed',\n    tests: ['oneOfType',[\n        {\n            schema: 'number',\n            tests: ['required',['min',5]]\n        },\n        {\n            schema: 'string',\n            tests: ['required','email']\n        }        \n    ]]\n};\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"\nconst num = number(tests(required(), min(5)));\nconst str = string(tests(required(), email()));\nmixed(tests(oneOfType([num,str])));\n"))),Object(r.b)("h2",{id:"combination"},"Combination"),Object(r.b)("p",null,"There are certain utility validators that can be used to combine/alter validators in certain ways."),Object(r.b)("h3",{id:"negate"},"negate"),Object(r.b)("p",null,"Inverts the logic for any validator. This validator is used internally for validator pairs like ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#same"}),"same"),"/",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#different"}),"different"),", ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#is"}),"is"),"/",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#not"}),"not")," and ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#oneOf"}),"oneOf"),"/",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#notOneOf"}),"notOneOf"),"."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'string',\n    // field must NOT be oneOf a, b, or c\n    tests: [['negate',['oneOf',['a','b','c']]]\n}\n\nmatches(schema,'f'); // true\nmatches(schema,'a'); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(tests(negate(oneOf(['a','b','c']))));\nisValidSync(schema,'f'); // true\nisValidSync(schema,'a'); // false\n"))),Object(r.b)("h3",{id:"combine"},"combine"),Object(r.b)("p",null,"Combines multiple validators into a new validator. Used internally to create the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"#between"}),"between")," validator."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = {\n    schema:'string',\n    tests: [['combine',[['min',5],['max',15]]]\n}\n\nmatches(schema,'at least 5'); // true\nmatches(schema,'no'); // false\nmatches(schema,'this is way longer than 15'); // false\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const schema = string(tests(combine(min(5),max(15))));\nisValidSync(schema,'at least 5'); // true\nisValidSync(schema,'no'); // false\nisValidSync(schema,'this is way longer than 15'); // false\n"))),Object(r.b)("h3",{id:"serial"},"serial"),Object(r.b)("p",null,'Essentially a "real" ',Object(r.b)("inlineCode",{parentName:"p"},"abortEarly:true")," for async validators."),Object(r.b)(c.a,{mdxType:"AstFn"},Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const firstAsync = async val => {\n    // do something async\n    // const result = await someAsyncFunc(val)\n    return val === 'bad';\n}\n\nconst secondAsync = async val => {\n    // do something async\n    // const result = await someAsyncFunc(val)\n    return val === 'good';\n}\n\n\nconst schema = createSchema(\n    {\n        schema:'string',\n        tests: [\n            [\n                'serial',\n                [\n                    ['firstAsync',{message:'Failed Async 1'}],\n                    ['secondAsync',{message:'Failed Async 2'}]\n                ]\n            ]\n        ]\n    },\n    // supply custom validators when compiling AST\n    {\n        validators: { firstAsync,secondAsync }\n    }\n);\n\nvalidate(createSchema(schema),'good'); // Promise<ValidationError> - Failed Async 1\nvalidate(createSchema(schema),'bad'); // Promise<ValidationError> - Failed Async 2\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"const firstAsync = async val => {\n    // do something async\n    // const result = await someAsyncFunc(val)\n    return val === 'bad';\n}\n\nconst secondAsync = async val => {\n    // do something async\n    // const result = await someAsyncFunc(val)\n    return val === 'good';\n}\n\nconst schema = string(tests(\n    test('firstAsync', firstAsync, { message:'Failed Async 1' }),\n    test('secondAsync', secondAsync, { message:'Failed Async 2' }),\n));\n\nvalidate(schema,'good', { abortEarly: false }); // Promise<ValidationError> - Failed Async 1\nvalidate(schema,'bad', { abortEarly: false }); // Promise<ValidationError> - Failed Async 2\n"))))}m.isMDXComponent=!0},90:function(e,a,t){"use strict";function n(e){var a,t,s="";if("string"==typeof e||"number"==typeof e)s+=e;else if("object"==typeof e)if(Array.isArray(e))for(a=0;a<e.length;a++)e[a]&&(t=n(e[a]))&&(s&&(s+=" "),s+=t);else for(a in e)e[a]&&(s&&(s+=" "),s+=a);return s}a.a=function(){for(var e,a,t=0,s="";t<arguments.length;)(e=arguments[t++])&&(a=n(e))&&(s&&(s+=" "),s+=a);return s}},91:function(e,a,t){"use strict";t.d(a,"a",(function(){return m})),t.d(a,"b",(function(){return u}));var n=t(0),s=t.n(n);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function c(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?c(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,s=function(e,a){if(null==e)return{};var t,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(s[t]=e[t]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=s.a.createContext({}),b=function(e){var a=s.a.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},m=function(e){var a=b(e.components);return s.a.createElement(o.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return s.a.createElement(s.a.Fragment,{},a)}},p=s.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),m=b(t),p=n,u=m["".concat(c,".").concat(p)]||m[p]||d[p]||r;return t?s.a.createElement(u,i(i({ref:a},o),{},{components:t})):s.a.createElement(u,i({ref:a},o))}));function u(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,c=new Array(r);c[0]=p;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var o=2;o<r;o++)c[o]=t[o];return s.a.createElement.apply(null,c)}return s.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},93:function(e,a,t){"use strict";var n=t(0),s=t(94);a.a=function(){var e=Object(n.useContext)(s.a);if(null==e)throw new Error("`useUserPreferencesContext` is used outside of `Layout` Component.");return e}},94:function(e,a,t){"use strict";var n=t(0),s=Object(n.createContext)(void 0);a.a=s},95:function(e,a,t){"use strict";t.d(a,"b",(function(){return u})),t.d(a,"a",(function(){return f}));var n=t(0),s=t.n(n),r=t(93),c=t(90),i=t(53),l=t.n(i),o=37,b=39;var m=function(e){var a=e.lazy,t=e.block,i=e.children,m=e.defaultValue,d=e.values,p=e.groupId,u=e.className,f=Object(r.a)(),j=f.tabGroupChoices,h=f.setTabGroupChoices,O=Object(n.useState)(m),g=O[0],v=O[1];if(null!=p){var y=j[p];null!=y&&y!==g&&d.some((function(e){return e.value===y}))&&v(y)}var N=function(e){v(e),null!=p&&h(p,e)},A=[];return s.a.createElement("div",null,s.a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:Object(c.a)("tabs",{"tabs--block":t},u)},d.map((function(e){var a=e.value,t=e.label;return s.a.createElement("li",{role:"tab",tabIndex:0,"aria-selected":g===a,className:Object(c.a)("tabs__item",l.a.tabItem,{"tabs__item--active":g===a}),key:a,ref:function(e){return A.push(e)},onKeyDown:function(e){!function(e,a,t){switch(t.keyCode){case b:!function(e,a){var t=e.indexOf(a)+1;e[t]?e[t].focus():e[0].focus()}(e,a);break;case o:!function(e,a){var t=e.indexOf(a)-1;e[t]?e[t].focus():e[e.length-1].focus()}(e,a)}}(A,e.target,e)},onFocus:function(){return N(a)},onClick:function(){N(a)}},t)}))),a?Object(n.cloneElement)(i.filter((function(e){return e.props.value===g}))[0],{className:"margin-vert--md"}):s.a.createElement("div",{className:"margin-vert--md"},i.map((function(e,a){return Object(n.cloneElement)(e,{key:a,hidden:e.props.value!==g})}))))},d=t(3);var p=function(e){var a=e.children,t=e.hidden,n=e.className;return s.a.createElement("div",Object(d.a)({role:"tabpanel"},{hidden:t,className:n}),a)},u=(t(91),function(e){var a=e.children,t=e.tabs,n=e.default;return s.a.createElement(m,{defaultValue:n||t[0],values:t.map((function(e){return{label:e,value:e}}))},t.map((function(e,t){return s.a.createElement(p,{key:e,value:e},a[t])})))}),f=function(e){var a=e.children,t=e.link;return s.a.createElement(s.a.Fragment,null,s.a.createElement(u,{tabs:["ast","functional"]},a),t&&s.a.createElement(s.a.Fragment,null,s.a.createElement("a",{target:"_blank",href:t},"Try it on CodeSandbox!"),s.a.createElement("hr",null),s.a.createElement("br",null)))}}}]);